/**
 *
 *	@file		base64.hpp
 *
 *	@brief		base64変換処理
 *
 *	@author		株式会社エムスクエア・ラボ　山形
 *
 *	@date		create : 2024/02/26
 *
 */
#include <Arduino.h>

/*==========================================================================================
	外部関数定義
==========================================================================================*/
const char base64[128] = {/*   |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  | */
                          /*   |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | */
                          /*0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          /*   |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     | */
                          /*1*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          /*   |     |     |     |     |     |     |     |     |     |     |     |  +  |     |     |     |  /  | */
                          /*2*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3F,
                          /*   |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |     |     |     |  =  |     |     | */
                          /*3*/ 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
                          /*   |     |  A  |  B  |  C  |  D  |  E  |  F  |  G  |  H  |  I  |  J  |  K  |  L  |  M  |  N  |  O   | */
                          /*4*/ 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
                          /*   |  P  |  Q  |  R  |  S  |  T  |  U  |  V  |  W  |  X  |  Y  |  Z  |     |     |     |     |     | */
                          /*5*/ 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
                          /*   |     |  a  |  b  |  c  |  d  |  e  |  f  |  g  |  h  |  i  |  j  |  k  |  l  |  m  |  n  |  o  | */
                          /*6*/ 0x00, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                          /*   |  p  |  q  |  r  |  s  |  t  |  y  |  v  |  w  |  x  |  y  |  z  |     |     |     |     |     | */
                          /*7*/ 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,};

/*==========================================================================================
	内部定数定義
==========================================================================================*/
// char i = '=';
/*==========================================================================================
	内部関数定義
==========================================================================================*/
/*==========================================================================================
	外部変数定義
==========================================================================================*/
/*==========================================================================================
	内部変数定義
==========================================================================================*/
/**
 *	@var		ssPins
 *	@brief		RFIDチャンネル
 */

/**
 *	@var		mfrc522
 *	@brief		各チャンネルインスタンス
 */


/*==========================================================================================
	関数
==========================================================================================*/

/**
 *	@brief		base64デコード
 *	@param		eData:エンコードデータアドレス
 *            eSaiz:エンコードサイズ
 *            dData:デコードデータ格納アドレス
 *            dSaiz:デコードサイズ
 *	@retval		result 0:変換失敗　1:変更成功
 */
int base64Decode(char* eData ,int eSaiz, uint8_t* dData ,int dSaiz){
  int bit = 0;
  int eCount = 0;
  int dCount = 0;
  int result = 1;
  int i = 0;
  int shift = 16;
  int mask  = 0xFF0000;
  int endFlag = 0;
	int endCount = 0;
  //エンコードサイズが4の場合のみ実行
  if(!(eSaiz%4)){
    for(eCount = 0; eCount < eSaiz;){
      bit = 0;
      //4文字ずつエンコードデータを合体
      for(i = 0; i < 4; i++){
          if((('0' <= eData[eCount])&&(eData[eCount] <= '9'))||
             (('a' <= eData[eCount])&&(eData[eCount] <= 'z'))||
             (('A' <= eData[eCount])&&(eData[eCount] <= 'Z'))||
             (eData[eCount] == '+')||
             (eData[eCount] == '/')||
             (eData[eCount] == '=')){

						if(eData[eCount] != '='){ // 終了文字のカウントをする
							endCount += 6;
						}
            bit |= int(base64[eData[eCount++]]);
            if(i < 3){
              bit <<= 6;
            }

          }else{  //Base64以外の文字列を受けたら中止
            Serial.println("Base64以外の文字列を受け取りました");
            result = 0;
            return result; 
          }
      }
      shift = 16;
      mask  = 0xFF0000;
      //8bit毎にデータを格納
      for(i = 0; i < 3; i++){
        //デコードサイズを超えた場合は終了
        if(dCount > dSaiz){ 
					Serial.println("デコードサイズを超えました");
          result = 0;
          return result;
        }
        dData[dCount++] = uint8_t((bit & mask)>>shift);

				endCount -= 8;	// 終了文字のカウントを減らす
				if(endCount < 8){ // 終了文字のカウントが8未満になったら終了
					break;
				}
        mask >>= 8;
        shift -= 8; 
      }
			result = dCount;
			endCount = 0;
    }
  }else{
		Serial.printf("エンコードサイズが4の倍数ではありません eSaiz:%d\n", eSaiz);
    result = 0;
  }
  return result;
}
